<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ObsidianSync Compressor</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#000000">
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2'%3E%3Cpath d='M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z'/%3E%3Ccircle cx='12' cy='13' r='3'/%3E%3C/svg%3E">
    <script type="module" src="https://unpkg.com/@capacitor/core@latest/dist/capacitor.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        * {
            font-family: system-ui, -apple-system, sans-serif;
        }
        .drop-zone {
            border: 2px dashed #e5e5e5;
            transition: all 0.2s ease;
        }
        .drop-zone:hover {
            border-color: #a3a3a3;
            background-color: #fafafa;
        }
        .drop-zone.dragover {
            border-color: #000;
            background-color: #f5f5f5;
        }
        .progress-bar {
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-white">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        function ObsidianSyncCompressor() {
            const [vaultHandle, setVaultHandle] = useState(null);
            const [status, setStatus] = useState('No folder selected');
            const [selectedImages, setSelectedImages] = useState([]);
            const [processing, setProcessing] = useState(false);
            const [progress, setProgress] = useState(0);
            const [compressionResults, setCompressionResults] = useState([]);
            const [isDragOver, setIsDragOver] = useState(false);
            const fileInputRef = useRef(null);
            const dropZoneRef = useRef(null);
            const [savedVaultName, setSavedVaultName] = useState(null);
            const [savedVaultPath, setSavedVaultPath] = useState(null);
            const [showPathInput, setShowPathInput] = useState(false);

            // Load saved vault from localStorage and handle file launching
            useEffect(() => {
                const saved = localStorage.getItem('obsidian-vault-name');
                const savedPath = localStorage.getItem('obsidian-vault-path');
                if (saved) {
                    setSavedVaultName(saved);
                    setSavedVaultPath(savedPath);
                    const pathInfo = savedPath ? ` at ${savedPath}` : '';
                    setStatus(`Previously used: ${saved}${pathInfo}`);
                }

                // Handle PWA file launching
                if ('launchQueue' in window && 'files' in LaunchParams.prototype) {
                    launchQueue.setConsumer((launchParams) => {
                        if (launchParams.files && launchParams.files.length) {
                            handleFileSelect(launchParams.files);
                            setStatus(`${launchParams.files.length} images opened from file manager`);
                        }
                    });
                }
            }, []);

            // Save vault info to localStorage/Capacitor
            const saveVaultInfo = (handle, path = null) => {
                const name = handle?.name || 'Obsidian Vault';
                localStorage.setItem('obsidian-vault-name', name);
                if (path) {
                    localStorage.setItem('obsidian-vault-path', path);
                    setSavedVaultPath(path);
                }
                const timestamp = new Date().toLocaleString();
                localStorage.setItem('obsidian-vault-last-used', timestamp);
                setSavedVaultName(name);
                
                // Also save to Capacitor preferences if available
                if (window.Capacitor?.isNativePlatform()) {
                    import('@capacitor/preferences').then(({ Preferences }) => {
                        Preferences.set({ key: 'obsidian-vault-name', value: name });
                        if (path) {
                            Preferences.set({ key: 'obsidian-vault-path', value: path });
                        }
                    });
                }
            };

            // Select Obsidian vault folder
            const selectVault = async () => {
                try {
                    const handle = await window.showDirectoryPicker({
                        startIn: 'documents',
                        mode: 'readwrite'
                    });
                    
                    setVaultHandle(handle);
                    saveVaultInfo(handle);
                    setStatus(`Connected to: ${handle.name}`);
                    
                    if ('storage' in navigator && 'persist' in navigator.storage) {
                        await navigator.storage.persist();
                    }
                } catch (err) {
                    setStatus('Folder selection cancelled');
                }
            };

            // Set custom path
            const setCustomPath = (path) => {
                if (path.trim()) {
                    localStorage.setItem('obsidian-vault-path', path);
                    setSavedVaultPath(path);
                    setStatus(`Path set: ${path} - Remember to navigate here when selecting folder`);
                }
                setShowPathInput(false);
            };

            // Use same folder (shows which folder to select)
            const useSameFolder = async () => {
                if (!savedVaultName) return;
                const lastUsed = localStorage.getItem('obsidian-vault-last-used');
                const timeInfo = lastUsed ? ` (last used ${lastUsed})` : '';
                const pathInfo = savedVaultPath ? `\nPath: ${savedVaultPath}` : '';
                setStatus(`Please navigate to and select your "${savedVaultName}" folder${timeInfo}${pathInfo}`);
                await selectVault();
            };

            // Smart compression - target exactly 4MB for optimal Obsidian sync
            const compressImage = async (file, targetSizeMB = 4) => {
                return new Promise((resolve) => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    const img = new Image();

                    img.onload = () => {
                        const originalSizeMB = file.size / (1024 * 1024);
                        let { width, height } = img;
                        const targetSize = targetSizeMB * 1024 * 1024;
                        
                        // If already under 4MB, do minimal compression
                        if (originalSizeMB <= 4) {
                            canvas.width = width;
                            canvas.height = height;
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            canvas.toBlob((blob) => {
                                resolve({
                                    blob,
                                    originalSize: file.size,
                                    compressedSize: blob.size,
                                    compressionRatio: ((file.size - blob.size) / file.size * 100).toFixed(1),
                                    wasAlreadySmall: true
                                });
                            }, 'image/jpeg', 0.95);
                            return;
                        }

                        // For larger files, use adaptive compression
                        let scaleFactor = 1;
                        if (originalSizeMB > 20) {
                            scaleFactor = 0.3;
                        } else if (originalSizeMB > 10) {
                            scaleFactor = 0.5;
                        } else if (originalSizeMB > 6) {
                            scaleFactor = 0.7;
                        } else {
                            scaleFactor = 0.85;
                        }

                        width = Math.floor(width * scaleFactor);
                        height = Math.floor(height * scaleFactor);

                        const maxDimension = 2048;
                        if (width > maxDimension || height > maxDimension) {
                            const ratio = Math.min(maxDimension / width, maxDimension / height);
                            width = Math.floor(width * ratio);
                            height = Math.floor(height * ratio);
                        }

                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0, width, height);

                        // Binary search for optimal quality
                        let minQuality = 0.1;
                        let maxQuality = 0.95;
                        let bestBlob = null;
                        let attempts = 0;
                        const maxAttempts = 10;

                        const findOptimalQuality = () => {
                            const quality = (minQuality + maxQuality) / 2;
                            
                            canvas.toBlob((blob) => {
                                attempts++;
                                
                                if (blob.size <= targetSize) {
                                    bestBlob = blob;
                                    
                                    if (blob.size > targetSize * 0.9 || attempts >= maxAttempts) {
                                        resolve({
                                            blob: bestBlob,
                                            originalSize: file.size,
                                            compressedSize: bestBlob.size,
                                            compressionRatio: ((file.size - bestBlob.size) / file.size * 100).toFixed(1),
                                            wasAlreadySmall: false,
                                            quality: quality.toFixed(2),
                                            dimensions: `${width}x${height}`
                                        });
                                    } else {
                                        minQuality = quality;
                                        findOptimalQuality();
                                    }
                                } else {
                                    maxQuality = quality;
                                    if (attempts >= maxAttempts && bestBlob) {
                                        resolve({
                                            blob: bestBlob,
                                            originalSize: file.size,
                                            compressedSize: bestBlob.size,
                                            compressionRatio: ((file.size - bestBlob.size) / file.size * 100).toFixed(1),
                                            wasAlreadySmall: false,
                                            quality: quality.toFixed(2),
                                            dimensions: `${width}x${height}`
                                        });
                                    } else {
                                        findOptimalQuality();
                                    }
                                }
                            }, 'image/jpeg', quality);
                        };

                        findOptimalQuality();
                    };

                    img.src = URL.createObjectURL(file);
                });
            };

            // Handle file selection
            const handleFileSelect = (files) => {
                const imageFiles = Array.from(files).filter(file => 
                    file.type.startsWith('image/')
                );
                setSelectedImages(imageFiles);
                setStatus(`${imageFiles.length} images selected`);
                setCompressionResults([]);
            };

            // Process and save images
            const processImages = async () => {
                if (!vaultHandle || selectedImages.length === 0) {
                    setStatus('Select folder and images first');
                    return;
                }

                setProcessing(true);
                setProgress(0);
                setCompressionResults([]);

                const results = [];
                
                for (let i = 0; i < selectedImages.length; i++) {
                    const file = selectedImages[i];
                    setStatus(`Compressing ${file.name}...`);
                    
                    try {
                        const compressed = await compressImage(file, 4);
                        
                        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                        const extension = file.name.split('.').pop();
                        const baseName = file.name.replace(`.${extension}`, '');
                        const fileName = `${baseName}-${timestamp}.jpg`;

                        const fileHandle = await vaultHandle.getFileHandle(fileName, { create: true });
                        const writable = await fileHandle.createWritable();
                        await writable.write(compressed.blob);
                        await writable.close();

                        results.push({
                            name: fileName,
                            ...compressed
                        });

                        setProgress(((i + 1) / selectedImages.length) * 100);
                    } catch (err) {
                        results.push({
                            name: file.name,
                            error: err.message
                        });
                    }
                }

                setCompressionResults(results);
                setProcessing(false);
                setProgress(100);
                setStatus(`Processed ${results.filter(r => !r.error).length} images`);
                setSelectedImages([]);
            };

            // Drag and drop handlers
            const handleDragOver = (e) => {
                e.preventDefault();
                setIsDragOver(true);
            };

            const handleDragLeave = (e) => {
                e.preventDefault();
                setIsDragOver(false);
            };

            const handleDrop = (e) => {
                e.preventDefault();
                setIsDragOver(false);
                handleFileSelect(e.dataTransfer.files);
            };

            // Format file size
            const formatSize = (bytes) => {
                if (bytes === 0) return '0 Bytes';
                const k = 1024;
                const sizes = ['Bytes', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            };

            return (
                <div className="min-h-screen bg-white p-6">
                    <div className="max-w-3xl mx-auto">
                        {/* Header */}
                        <div className="mb-8">
                            <h1 className="text-4xl font-bold text-black mb-2">ObsidianSync</h1>
                            <p className="text-neutral-600">Compress images for Obsidian vault syncing</p>
                        </div>

                        {/* Main Container */}
                        <div className="border border-neutral-200 rounded-lg bg-white">
                            {/* Vault Selection */}
                            <div className="p-6 border-b border-neutral-200">
                                <div className="flex gap-2 mb-3">
                                    <button
                                        onClick={selectVault}
                                        className="flex-1 bg-black text-white px-4 py-2 rounded-md hover:bg-neutral-800 transition-colors font-medium"
                                    >
                                        {vaultHandle ? 'Change Folder' : 'Select Obsidian Vault'}
                                    </button>
                                    {savedVaultName && !vaultHandle && (
                                        <button
                                            onClick={useSameFolder}
                                            className="px-4 py-2 border border-neutral-300 rounded-md hover:bg-neutral-50 transition-colors font-medium"
                                            title={`Browser security requires reselecting "${savedVaultName}" each session`}
                                        >
                                            Select "{savedVaultName}"
                                        </button>
                                    )}
                                    <button
                                        onClick={() => setShowPathInput(!showPathInput)}
                                        className="px-3 py-2 border border-neutral-300 rounded-md hover:bg-neutral-50 transition-colors text-sm"
                                        title="Set custom path reminder"
                                    >
                                        📁
                                    </button>
                                </div>
                                
                                {showPathInput && (
                                    <div className="flex gap-2">
                                        <input
                                            type="text"
                                            placeholder="/home/merle/Documents/Obsidian/Em's Nexus (dykeDiaries)/life_os/pictures"
                                            className="flex-1 px-3 py-2 border border-neutral-300 rounded-md text-sm"
                                            defaultValue={savedVaultPath || ''}
                                            onKeyPress={(e) => {
                                                if (e.key === 'Enter') {
                                                    setCustomPath(e.target.value);
                                                }
                                            }}
                                        />
                                        <button
                                            onClick={(e) => {
                                                const input = e.target.parentElement.querySelector('input');
                                                setCustomPath(input.value);
                                            }}
                                            className="px-3 py-2 bg-black text-white rounded-md hover:bg-neutral-800 transition-colors text-sm"
                                        >
                                            Set
                                        </button>
                                    </div>
                                )}
                            </div>

                            {/* File Upload Zone */}
                            <div className="p-6 border-b border-neutral-200">
                                <div
                                    ref={dropZoneRef}
                                    className={`drop-zone rounded-md p-12 text-center cursor-pointer ${isDragOver ? 'dragover' : ''}`}
                                    onDragOver={handleDragOver}
                                    onDragLeave={handleDragLeave}
                                    onDrop={handleDrop}
                                    onClick={() => fileInputRef.current?.click()}
                                >
                                    <h3 className="text-lg font-semibold text-neutral-700 mb-2">
                                        Drop images here or click to select
                                    </h3>
                                    <p className="text-neutral-500 text-sm">
                                        JPG, PNG, WebP - Optimized for document photos
                                    </p>
                                    <input
                                        ref={fileInputRef}
                                        type="file"
                                        multiple
                                        accept="image/*"
                                        className="hidden"
                                        onChange={(e) => handleFileSelect(e.target.files)}
                                    />
                                </div>
                            </div>

                            {/* Selected Images Preview */}
                            {selectedImages.length > 0 && (
                                <div className="p-6 border-b border-neutral-200">
                                    <h3 className="text-sm font-semibold text-neutral-700 mb-3">
                                        SELECTED FILES ({selectedImages.length})
                                    </h3>
                                    <div className="space-y-2">
                                        {selectedImages.slice(0, 5).map((file, idx) => (
                                            <div key={idx} className="flex justify-between items-center py-1">
                                                <span className="text-sm text-neutral-600 truncate max-w-xs">{file.name}</span>
                                                <span className="text-sm text-neutral-500">{formatSize(file.size)}</span>
                                            </div>
                                        ))}
                                        {selectedImages.length > 5 && (
                                            <p className="text-sm text-neutral-500">
                                                +{selectedImages.length - 5} more files
                                            </p>
                                        )}
                                    </div>
                                </div>
                            )}

                            {/* Process Button */}
                            <div className="p-6">
                                <button
                                    onClick={processImages}
                                    disabled={!vaultHandle || selectedImages.length === 0 || processing}
                                    className="w-full bg-black text-white px-4 py-2 rounded-md hover:bg-neutral-800 transition-colors font-medium disabled:opacity-50 disabled:cursor-not-allowed"
                                >
                                    {processing ? 'Compressing...' : 'Compress & Save'}
                                </button>

                                {/* Progress Bar */}
                                {processing && (
                                    <div className="mt-4">
                                        <div className="bg-neutral-200 rounded-full h-2 overflow-hidden">
                                            <div
                                                className="progress-bar bg-black h-full rounded-full"
                                                style={{ width: `${progress}%` }}
                                            ></div>
                                        </div>
                                        <p className="text-center text-sm text-neutral-600 mt-2">{progress.toFixed(0)}%</p>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Status */}
                        <div className="mt-4 p-4 bg-neutral-50 border border-neutral-200 rounded-lg">
                            <p className="text-sm text-neutral-700">{status}</p>
                        </div>

                        {/* Results */}
                        {compressionResults.length > 0 && (
                            <div className="mt-4 border border-neutral-200 rounded-lg bg-white">
                                <div className="p-4 border-b border-neutral-200">
                                    <h3 className="font-semibold text-black">Results</h3>
                                </div>
                                <div className="divide-y divide-neutral-100">
                                    {compressionResults.map((result, idx) => (
                                        <div key={idx} className="p-4">
                                            <div className="flex justify-between items-start">
                                                <div className="flex-1">
                                                    <p className="font-medium text-neutral-800 text-sm">{result.name}</p>
                                                    {result.error ? (
                                                        <p className="text-red-600 text-sm mt-1">Error: {result.error}</p>
                                                    ) : (
                                                        <p className="text-neutral-600 text-sm mt-1">
                                                            {formatSize(result.originalSize)} → {formatSize(result.compressedSize)} 
                                                            ({result.compressionRatio}% reduced)
                                                            {result.wasAlreadySmall && " - minimal compression"}
                                                        </p>
                                                    )}
                                                </div>
                                            </div>
                                        </div>
                                    ))}
                                </div>
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        ReactDOM.render(<ObsidianSyncCompressor />, document.getElementById('root'));
    </script>
</body>
</html>